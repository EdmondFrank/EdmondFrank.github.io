
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="ja"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>EdmondFrank's 时光足迹</title>
  <meta name="author" content="EdmondFrank">

  
  <meta name="description" content="0x1 基本介绍 首先，在编写Rails应用时，代码会预加载：通过约定类定义所在的文件名与类名一致映射，实现自动加载 Rails 通过config.cache_classes参数来设置常见加载的模式，主要有以下两种形式： Kernel#require(一般用于生产环境，只加载一次)
Kernel# &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="https://edmondfrank.github.io/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="EdmondFrank's 时光足迹" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.cat.net/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
   <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_SVG"></script>
  
  

</head>

<body >
  <div id="container">
    <header role="banner"><hgroup>
  <h1><a href="/">EdmondFrank's 时光足迹</a></h1>
  
    <h2>この先は暗い夜道だけかもしれない　それでも信じて進むんだ。星がその道を少しでも照らしてくれるのを。<br>或许前路永夜，即便如此我也要前进，因为星光即使微弱也会我为照亮前途。<br>——《四月は君の嘘》</h2>
  
</hgroup>

</header>
    <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="site:edmondfrank.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/archives">Archives</a></li>
</ul>

</nav>
    <div id="main">
      <div id="content">
        <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2020/04/09/rails-chang-liang-jia-zai-ji-zhi/">Rails 常量加载机制</a></h1>
    
    
      <div class="post-meta">
        <p class="meta">
          <span class="timestamp">- 








  



<time datetime="2020-04-09T09:12:45+08:00" pubdate data-updated="true"></time> -</span>
          
        </p>
      </div>
    
  </header>


  <div class="entry-content"><h2>0x1 基本介绍</h2>

<p>首先，在编写Rails应用时，代码会预加载：通过约定类定义所在的文件名与类名一致映射，实现自动加载</p>

<p>Rails 通过config.cache_classes参数来设置常见加载的模式，主要有以下两种形式：</p>

<ul>
<li>Kernel#require(一般用于生产环境，只加载一次)</li>
<li>Kernel#load（一般用于开发环境）</li>
</ul>


<p>除了加载的方式不同，在<code>config.cache_classes = false</code>时，Rails还会启用Reloader中间件
在代码发生变更时，通过<code>remove_constant</code>/<code>const_missing</code>等方法实现么常量、模块热替换</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># railties-4.0.13/lib/rails/application.rb:384
</span><span class='line'>unless config.cache_classes
</span><span class='line'>    middleware.use ::ActionDispatch::Reloader, lambda { app.reload_dependencies? }
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>下面，本文逐步解析下Ruby及Rails下的常量加载机制</p>

<h2>0x2 常量刷新机载</h2>

<p>Ruby中常见的常量：
- 模块 module
- 类 class
- 自定义常量</p>

<p>其中，既然module和class在Ruby中本质就是常量的话，类和模块定义的嵌套创建的命名空间也是常量了</p>

<p>Ruby 的常量嵌套从内向外展开，嵌套通过Module.nesting方法审查</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>module X
</span><span class='line'>  module Y
</span><span class='line'>    def self.test
</span><span class='line'>      puts Module.nesting
</span><span class='line'>    end
</span><span class='line'>  end
</span><span class='line'>end
</span><span class='line'>X::Y.test
</span><span class='line'>
</span><span class='line'>module A
</span><span class='line'>  module B
</span><span class='line'>     def self.test
</span><span class='line'>      puts Module.nesting
</span><span class='line'>    end
</span><span class='line'>  end
</span><span class='line'>end
</span><span class='line'>A::B.test
</span><span class='line'>
</span><span class='line'>module X::Y
</span><span class='line'>  module A::B
</span><span class='line'>    def self.test
</span><span class='line'>      puts Module.nesting
</span><span class='line'>    end
</span><span class='line'>  end
</span><span class='line'>end
</span><span class='line'>A::B.test
</span><span class='line'>
</span><span class='line'># &gt;&gt;
</span><span class='line'>#[X::Y, X]
</span><span class='line'>#[A::B, A]
</span><span class='line'>#[A::B, X::Y]</span></code></pre></td></tr></table></div></figure>


<p>从上面的例子看出，嵌套中的类和模块的名称与所在的命名空间没有必然联系</p>

<p>嵌套是解释器维护的一个内部堆栈，根据下述规则修改：
1. 执行 class 关键字后面的定义体时，类对象入栈；执行完毕后出栈。
2. 执行 module 关键字后面的定义体时，模块对象入栈；执行完毕后出栈。
3. 执行 class &lt;&lt; object 打开的单例类时，类对象入栈；执行完毕后出栈。
4. 调用 <code>instance_eval</code> 时如果传入字符串参数，接收者的单例类入栈求值的代码所在的嵌套层次。
5. 调用 <code>class_eval</code> 或 <code>module_eval</code> 时如果传入字符串参数，接收者入栈求值的代码所在的嵌套层次.
6. 顶层代码中由 Kernel#load 解释嵌套是空的，除非调用 load 时把第二个参数设为真值；如果是这样，Ruby 会创建一个匿名模块，将其入栈。</p>

<p>定义类和模块的本质是为常量赋值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class C
</span><span class='line'>end
</span><span class='line'># =&gt; 本质：在Object中创建一个常量C，并将一个类对象存储进去
</span><span class='line'>
</span><span class='line'>class Project &lt; ApplicationRecord
</span><span class='line'>end
</span><span class='line'>＃ =&gt; 本质：Project = Class.new(ApplicationRecord)
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>module Admin
</span><span class='line'>end
</span><span class='line'># =&gt; 本质：Admin = Module.new
</span><span class='line'>
</span><span class='line'>Admin.name # =&gt; "Admin"</span></code></pre></td></tr></table></div></figure>


<p>常量赋值的一条特殊规则：如果被赋值的对象是匿名类或模块，Ruby 会把对象的名称设为常量的名称。</p>

<p>自此之后常量和实例发生的事情无关紧要。例如，可以把常量删除，类对象可以赋值给其他常量，或者不再存储于常量中，等等。名称一旦设定就不会再变。</p>

<h2>0x3 常量解析</h2>

<h3>0x31 映射</h3>

<p>当常量存储在模块中，常量就会和类和模块中的常量表关联映射（类似哈希表）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>module Colors
</span><span class='line'>    RED = '0xff0000'
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>解析模块定义体时，会在Colors常量中的常量表新建一条映射，把"RED"映射到字符串"0xff0000"</p>

<h3>0x32 Ruby下的解析</h3>

<p>相对常量、绝对常量、限定常量</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Billing::Invoice #此时，Billing为相对常量，Invoice为限定常量
</span><span class='line'>::Billing::Invoice #此时，Billing为绝对常量（顶层常量）在Object中查找</span></code></pre></td></tr></table></div></figure>


<p>相对常量解析：
在代码中的特定位置，假如使用 cref 表示嵌套中的第一个元素，如果没有嵌套，则表示 Object。</p>

<ol>
<li>嵌套不为空，在嵌套元素中按元素顺序查找，元素祖先忽略不记</li>
<li>未果，向上回溯，进去cref的祖先链</li>
<li>未果，当cref为module时，进入Object查找常量</li>
<li>未果，在cref上调用const_missing，默认抛出NameError异常，可覆写</li>
</ol>


<p>限定常量解析：
上面例子 Invoice 由 Billing 限定，解析算法如下</p>

<ol>
<li>在 Billing 及其祖先中查找 Invoice 常量</li>
<li>未果，调用 Billing 的const_missing方法，默认抛出NameError异常</li>
</ol>


<p>但Rails 的自动加载机制没有仿照这个算法，查找的起点是要自动加载的常量名称和限定的类或模块对象</p>

<p>如果缺失限定常量，Rails 不会在父级命名空间中查找。</p>

<p>但是有一点要留意：缺失常量时，Rails 不知道它是相对引用还是限定引用。</p>

<p>如果类或模块的父级命名空间中没有缺失的常量，Rails 假定引用的是相对常量。否则是限定常量。</p>

<p>还有在Rails开发环境中，常量时惰性加载的。遇到不存在的常量再触发<code>const_missing</code>使用Rails的自动加载机制</p>

<p>但在生产环境中，预先把所有 autoload 目录下的文件都加载过了。没有触发<code>const_missing</code>使用Ruby本身的常量查找</p>

<h2>0x4 加载机制</h2>

<p>config.cache_classes 设为 false 时，Rails 会重新自动加载常量</p>

<p>在应用运行的过程中，如果相关的逻辑有变，会重新加载代码。为此，Rails 会监控下述文件：</p>

<ul>
<li>config/routes.rb</li>
<li>本地化文件</li>
<li>autoload_paths 中的 Ruby 文件</li>
<li>db/schema.rb 和 db/structure.sql</li>
</ul>


<p>如果这些文件中的内容有变，有个中间件会发现，然后重新加载代码。</p>

<p>主要原理：
1. 先覆写 <code>const_missing</code> 方法，按需去load对应依赖
2. 监听文件变化，自动加载机制会记录自动加载的常量
3. 检测到发生变更，重新加载机制使用 Module#remove_const 方法把它们从相应的类和模块中删除
4. 这样，运行代码时那些常量就变成未知了，从而按需重新加载文件。</p>

<p>但是，因为类之间的依赖极难处理。Rails默认reloader模块经常比较极端，不止重新加载有变化的代码，而是重载一切</p>

<h3>0x41 Ruby Module#autoload 的缺陷</h3>

<p>Module#autoload 是Ruby 提供的惰性常量加载机制，可以遍历应用树调用autoload把文件名和常规的常量名对应起来</p>

<p>但是，Module#autoload 只能使用 require 加载文件，因此无法重新加载。</p>

<p>不仅如此，它使用的还仅是 require 关键字，而不是 Kernel#require 方法。</p>

<p>因此，删除文件后，它无法移除声明。如果使用 Module#remove_const 把常量删除了，不会触发 Module#autoload</p>

<p>综上，在Rails的常量自动加载机制中使用了覆写Module#const_missing 的方式来实现</p>

<p>Rails(ActiveSupport) 中的会根据触发 const_missing 的常量名称来猜测并尝试加载对应的文件, 以加载 Auth::User 为例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># demo/role.rb
</span><span class='line'>module Demo
</span><span class='line'>  class Role
</span><span class='line'>    User
</span><span class='line'>  end
</span><span class='line'>end
</span><span class='line'>
</span><span class='line'># demo/user.rb
</span><span class='line'>module Demo
</span><span class='line'>  class User
</span><span class='line'>    "class Demo::User loaded"
</span><span class='line'>  end
</span><span class='line'>end
</span><span class='line'>
</span><span class='line'># app/models/auth/user.rb
</span><span class='line'>module Auth
</span><span class='line'>  class User
</span><span class='line'>  end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>Demo::Role 找不到 User 常量, 触发 <code>const_missing(const_name)</code>, 此处 <code>const_name == 'User'</code></p>

<p>ActiveSupport 中先拼接出来一个查询的起点 &ldquo;#{Demo::Role.name}::#{const_name}&rdquo;, 即 Demo::Role::User</p>

<p>首先尝试查找 autoload_paths 下的 demo/role/user.rb, 没找到</p>

<p>然后往上走一层, 尝试查找 autoload_paths 下的 demo/user.rb, 找到了</p>
</div>
  
  


      <footer>
      
      - <a href="/blog/2020/04/09/rails-chang-liang-jia-zai-ji-zhi/">Rails 常量加载机制</a>
      <time datetime="2020-04-09T09:12:45+08:00" pubdate><span class='month'>Apr</span> <span class='day'>09</span> <span class='year'>2020</span></time>
      
      <span class="categories">posted in <a class='category' href='/blog/categories/rails/'>rails</a></span>
      
      </footer>
    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2019/11/29/magit-inside-emacs/">Magit Inside Emacs</a></h1>
    
    
      <div class="post-meta">
        <p class="meta">
          <span class="timestamp">- 








  



<time datetime="2019-11-29T12:50:31+08:00" pubdate data-updated="true"></time> -</span>
          
        </p>
      </div>
    
  </header>


  <div class="entry-content"><h3>基本介绍</h3>

<p><a href="https://magit.vc/">Magit</a> 是 Emacs 下对git的封装，利用Magit可以让你在Emacs中即可完成对git仓库的管理（Emacs果然是一个伪装成编辑器的操作系统）</p>

<p>其次，Magit本不是Emacs的内置插件，使用时需要自己安装；具体的安装方法在Magit的官网上已经有<a href="https://magit.vc/manual/magit/Installing-from-Melpa.html#Installing-from-Melpa">相关教程</a>了，这里我就不再赘述了</p>

<h3>日常使用</h3>

<p>下面主要是列举一些日常开发和git管理中比较常使用的一些功能：</p>

<h4>1. M-x:magit-status(C-x g)</h4>

<p><img src="https://i.loli.net/2019/11/29/45276NGocmKRHdQ.png" alt="magit-status.png" />
该命令就类似于git status（查看项目的当前状态）；但是，在Magit中显示的状态信息会比git status更加丰富
其中包括：HEAD、Tag、未追踪文件、Stash列表、未staged文件、未push文件、最近commit等信息
然后，在相应的条目上回车还可以进行看到更加详细的内容，包括对应文件的修改、具体的commit信息等等</p>

<h4>2. (?) Magit Help</h4>

<p><img src="https://i.loli.net/2019/11/29/CZwBqeMlRDr24oI.png" alt="magit-help.png" />
在magit status buffer中键入？可以提示Magit的功能列表以及其相对应的key bindings，新手通过这样一个帮助列表，就可以找到对应的git功能一一操作试试，一段时间后就可以熟悉整个magit的操作了</p>

<h4>3. （s/S）Stage/Stage all</h4>

<p>Stage命令就类似于git add操作，在你修改了相关的git管理下的文件后，若是还未运行git add时，该文件处于Unstaged的状态
处于Unstaged状态的文件在git commit的时候其变更内容就不会提交；而运行git add [filename] 之后文件就变成Stage状态了，
此时如果再执行git commit，对应的文件变更内容则提交到本地，然后文件状态变更未Unpushed</p>

<h4>4. (u/U) Unstage/Unstage all</h4>

<p>Unstage命令就是Stage命令的反向操作，其对应git reset HEAD [filename]，在Magit中Stage/Unstage不仅能够作用于单个文件、所有的changes，还能作用于某个文件的部分区域上；在magit展开文件的diff时，你还发现在文件差异中用@@符号区分的差异区域，在对应的区域内键入Stage/Unstage命令即可仅仅存在该区域中的变更，然后在commit提交时，也可以单单提交这一部分变更</p>

<p><img src="https://i.loli.net/2019/11/29/J9Zq7wpPkUKn2ts.png" alt="diff.png" /></p>

<h4>5. &copy; Commit</h4>

<p>在magit-status-buffer中键入c键即为最常用的git commit指令，当然后除了最普通的Commit（cc）操作外
Magit还支持许多commit的扩展命令</p>

<table>
<thead>
<tr>
<th> key bindings </th>
<th> command </th>
<th> description                                                      </th>
</tr>
</thead>
<tbody>
<tr>
<td> cc           </td>
<td> Commit  </td>
<td> 最普通的 git commit                                              </td>
</tr>
<tr>
<td> ce           </td>
<td> Extend  </td>
<td> 当前Staged的文件合并到上一次提交中 git commit –amend –no-edit      </td>
</tr>
<tr>
<td> ca           </td>
<td> Amend   </td>
<td> 只修改上次提交的日志   git commit –amend                           </td>
</tr>
</tbody>
</table>


<h4>6. (F) Pull</h4>

<p>Pull命令对应git pull在git管理中用于拉取远程仓库代码，常用的组合命令有以下：</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> key bindings </th>
<th style="text-align:center;"> description                          </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> Fu           </td>
<td style="text-align:center;"> pull from upstream                   </td>
</tr>
<tr>
<td style="text-align:center;"> Fp           </td>
<td style="text-align:center;"> pull from pushremote                 </td>
</tr>
<tr>
<td style="text-align:center;"> Fe           </td>
<td style="text-align:center;"> pull from elsewhere 会引导你从哪pull   </td>
</tr>
</tbody>
</table>


<p>对于Fu 和 Fp来说，upstream是pushremote的上级，这样的场景对应fork分支开发的工作流；
比如User A 有个仓库 Project，User B fork了Project，这样对于User B来说
UserA/Project就是upstream，而pushremote是UserB/Project
另外，在Magit中只有设置了pushremote分支，这样magit status buffer才会显示有哪些变更没有push和pull</p>

<h4>7. (P) Push</h4>

<p>对应git push 命令</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> key bindings </th>
<th style="text-align:left;"> command                </th>
<th style="text-align:left;"> description                </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> pu           </td>
<td style="text-align:left;"> push to upstream       </td>
<td style="text-align:left;"> 最普通的git push            </td>
</tr>
<tr>
<td style="text-align:left;"> pe           </td>
<td style="text-align:left;"> push to elsewhere      </td>
<td style="text-align:left;"> 会引导你push到哪个远程分支    </td>
</tr>
<tr>
<td style="text-align:left;"> po           </td>
<td style="text-align:left;"> push another branch to </td>
<td style="text-align:left;"> 会引导你push到哪个分支       </td>
</tr>
<tr>
<td style="text-align:left;"> pT           </td>
<td style="text-align:left;"> push a tag             </td>
<td style="text-align:left;"> push 一个tag标签            </td>
</tr>
<tr>
<td style="text-align:left;"> pt           </td>
<td style="text-align:left;"> push all tag           </td>
<td style="text-align:left;"> push 所有tag标签            </td>
</tr>
</tbody>
</table>


<p>除此之外，上面的key bindings组合还可以添加对应的扩展参数，比如强制push，即p-Fu</p>

<h4>8. (l) Log查看日志</h4>

<p>对应git log，查看git日志记录</p>

<table>
<thead>
<tr>
<th> key bindings </th>
<th> description                  </th>
</tr>
</thead>
<tbody>
<tr>
<td> ll           </td>
<td> 查看当前分支的日志             </td>
</tr>
<tr>
<td> lo           </td>
<td> log other 查看其他分支的日志   </td>
</tr>
</tbody>
</table>


<p>在具体的commit上使用 l 键还可以根据给出的命令组合进一步查看commit提交的详情信息</p>

<h4>9. (a/A) cherry picking</h4>

<p>对应git cherry-pick，选择某一次的commit在当前分支重新commit一次，适用于合并代码但又不想merge整个PR和分支的场景</p>

<h4>10. (z)Stash</h4>

<p>对应git Stash，将临时的未commit的变更内容暂存起来
常用命令有：</p>

<table>
<thead>
<tr>
<th> key bindings </th>
<th> command       </th>
<th> description </th>
</tr>
</thead>
<tbody>
<tr>
<td> zz           </td>
<td> git stash     </td>
<td> 暂存        </td>
</tr>
<tr>
<td> zp           </td>
<td> git stash pop </td>
<td> 恢复        </td>
</tr>
</tbody>
</table>


<p>除此之外，还有一个有意思的用法是，当你希望单单想stash变更文件列表中的一个文件时，可以先将目标文件Stage在index索引区，然后适用 zi 组合暂存index区域，这样就可以实现单一文件的stash功能</p>

<h4>11. (k) Discard/Delete</h4>

<p>对应git中的checkout之类的命令，用作于放弃更改和删除相关的操作，例如，放弃一个Unstage文件的更改、删除一个Stash、删除一个@@区域差异等等</p>

<h4>12. (x) Resetting</h4>

<p>类似git reset命令，放弃最近的n次提交，这n次的提交内容变成staged状态，之后可以进行合并提交或者丢弃
只需要在日志日光标定位到想要丢弃的log,即可回滚到这一次的提交状态</p>

<h4>13. (m) Merge</h4>

<p>对应git中合并分支的操作，常用的组合命令为 mm ，之后会提示选择与哪个分支进行merge</p>

<h4>14. &reg; Rebase</h4>

<p>对应git中的变基操作</p>

<table>
<thead>
<tr>
<th> key bindings </th>
<th> description                        </th>
</tr>
</thead>
<tbody>
<tr>
<td> ru           </td>
<td> rebase on upstream                 </td>
</tr>
<tr>
<td> rp           </td>
<td> rebase on pushremote               </td>
</tr>
<tr>
<td> re           </td>
<td> 会提示你以哪个分支为基点进行rebase     </td>
</tr>
</tbody>
</table>

</div>
  
  


      <footer>
      
      - <a href="/blog/2019/11/29/magit-inside-emacs/">Magit inside Emacs</a>
      <time datetime="2019-11-29T12:50:31+08:00" pubdate><span class='month'>Nov</span> <span class='day'>29</span> <span class='year'>2019</span></time>
      
      <span class="categories">posted in <a class='category' href='/blog/categories/emacs/'>emacs</a></span>
      
      </footer>
    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2019/11/27/railsde-activesupport-concern/">Railsçš„ActiveSupport::Concern</a></h1>
    
    
      <div class="post-meta">
        <p class="meta">
          <span class="timestamp">- 








  



<time datetime="2019-11-27T18:47:49+08:00" pubdate data-updated="true"></time> -</span>
          
        </p>
      </div>
    
  </header>


  <div class="entry-content"><h3>1）简单内部类</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">ActiveSupport::Concern</span>
</span><span class='line'>  <span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">MultipleIncludedBlocks</span> <span class="o">&lt;</span> <span class="no">StandardError</span> <span class="c1">#:nodoc:</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">initialize</span>
</span><span class='line'>      <span class="k">super</span> <span class="s2">&quot;Cannot define multiple &#39;included&#39; blocks for a Concern&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>ActiveSupport::Concern简单定义了一个内部的错误类型，
这个自定义错误类型主要用于提醒我们在扩展了ActiveSupport::Concern的模块中</p>

<p>只能够显式调用模块方法ActiveSupport::Concern::included一次，</p>

<p>第二次调用的话就会抛出这个自定义的错误类型。</p>

<h3>2）设置“胎记”</h3>

<p>我们前面说过扩展了ActiveSupport::Concern的模块我把它简称为依赖模块，那我们怎么知道一个模块是不是依赖模块呢？答案就在这个类方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">ActiveSupport::Concern</span>
</span><span class='line'>  <span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">extended</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="c1">#:nodoc:</span>
</span><span class='line'>    <span class="n">base</span><span class="o">.</span><span class="n">instance_variable_set</span><span class="p">(</span><span class="ss">:@_dependencies</span><span class="p">,</span> <span class="o">[]</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>写过Ruby的应该都知道，这个是当一个模块被扩展(extend)之后就会被调用的一个回调方法，</p>

<p>并以扩展它的模块做为参数(base)传入该回调方法。</p>

<p>当一个模块扩展了ActiveSupport::Concern之后就会在模块内部设置一个实例变量</p>

<p>@_dependencies并设置为空数组，我们姑且把它看做是ActiveSupport::Concern的“胎记”，</p>

<p>后面我们会利用这个“胎记”所包含的依赖项，优雅地增强我们的终端模块。</p>

<h3>3) 收集并扩展相关方法</h3>

<p>在分析后面的方法之前我们先来简单看一下的原理。</p>

<p>我们都知道在Ruby里面如何定义一个类，并且定义相关的类方法，和实例方法</p>

<p>（我们只需要用class关键字就能够很容易做到这一点），但不知道大家是否了解还有这样一种方式？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">instance_block</span> <span class="o">=</span> <span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">instance_method</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;I am instance method&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">class_method_in_instance_block</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;I am class method in instance block&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">class_block</span> <span class="o">=</span> <span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">class_method</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;I am class method&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="no">Example</span> <span class="o">=</span> <span class="no">Class</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'>
</span><span class='line'><span class="no">Example</span><span class="o">.</span><span class="n">class_eval</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance_block</span><span class="p">)</span>
</span><span class='line'><span class="no">ClassModule</span> <span class="o">=</span> <span class="no">Module</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'><span class="no">ClassModule</span><span class="o">.</span><span class="n">module_eval</span><span class="p">(</span><span class="o">&amp;</span><span class="n">class_block</span><span class="p">)</span>
</span><span class='line'><span class="no">Example</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="no">ClassModule</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="no">Example</span><span class="o">.</span><span class="n">class_method</span>
</span><span class='line'><span class="no">Example</span><span class="o">.</span><span class="n">class_method_in_instance_block</span>
</span><span class='line'><span class="no">Example</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">instance_method</span>
</span></code></pre></td></tr></table></div></figure>


<p>运行结果</p>

<blockquote><p>I am class method
I am class method in instance block
I am instance method</p></blockquote>

<p>运行结果有点意思，下面简单来分析一下:
我们以代码块的方式收集了类方法class_method，class_method_in_instance_block，</p>

<p>以及实例方法instance_method。然后我们创建一个空的类Example，</p>

<p>用Class#class_eval方法来打开类，在类的上下文环境下运行块instance_block，</p>

<p>其实这就相当于我们在类上下文中运行相应的语句，这样就能够得到Example#instance_method,</p>

<p>Example::class_method_in_instance_block这两个方法了。
另外，我们从已有的知识中了解到，可以通过Class#extend扩展模块的方式来获得类方法。</p>

<p>为此我们可以把class_block这个代码块包裹在模块ClassModule中，</p>

<p>最后我们只需要扩展(extend)这个模块就可以得到相应的类方法Example#class_method了。</p>

<p>ActiveSupport::Concern其实就是这种黑科技，</p>

<p>这里我简单把接下来的过程分为两部分</p>

<p>1）收集方法。</p>

<p>2）对收集的方法进行功能扩展</p>

<ol type="a">
<li>方法收集
来看看依赖模块如何收集方法的？</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">ActiveSupport::Concern</span>
</span><span class='line'>  <span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">included</span><span class="p">(</span><span class="n">base</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">base</span><span class="o">.</span><span class="n">nil?</span>
</span><span class='line'>      <span class="k">raise</span> <span class="no">MultipleIncludedBlocks</span> <span class="k">if</span> <span class="n">instance_variable_defined?</span><span class="p">(</span><span class="ss">:@_included_block</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>      <span class="vi">@_included_block</span> <span class="o">=</span> <span class="n">block</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="k">super</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>首先我们来看ActiveSupport::Concern#included，</p>

<p>当ActiveSupport::Concern被扩展之后这个included方法就会变成相应模块的类方法了。</p>

<p>咦，这不是一个模块被包含之后才会被调用的回调函数吗？没错，为了不影响它原来的功能rails团队采用了个巧妙的做法，</p>

<p>当我们在扩展了ActiveSupport::Concern的模块的上下文中显式调用included方法，</p>

<p>并且不带任何参数而只传入代码块的情况下，便会在模块内部设置一个@_included_block实例变量来接收这个代码块，</p>

<p>换句话说这个实例变量就是我们将来需要在终端模块上下文运行的代码块。</p>

<p>而在其他情况下则通过super关键字来调用原始版本的included方法。</p>

<p>这样既增强了included方法又不影响原始方法的使用。</p>

<p>另外我们也注意到了，在一个模块里面included方法只能被显式调用一次，</p>

<p>否则会抛出MultipleIncludedBlocks这个自定义的错误，这便是前面定义的内部类的应用场景。</p>

<p>OK，收集完需要在模块上下文运行的代码，我们接下来要收集类方法了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">ActiveSupport::Concern</span>
</span><span class='line'>  <span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">class_methods</span><span class="p">(</span><span class="o">&amp;</span><span class="n">class_methods_module_definition</span><span class="p">)</span>
</span><span class='line'>    <span class="n">mod</span> <span class="o">=</span> <span class="nb">const_defined?</span><span class="p">(</span><span class="ss">:ClassMethods</span><span class="p">,</span> <span class="kp">false</span><span class="p">)</span> <span class="p">?</span>
</span><span class='line'>      <span class="nb">const_get</span><span class="p">(</span><span class="ss">:ClassMethods</span><span class="p">)</span> <span class="p">:</span>
</span><span class='line'>      <span class="nb">const_set</span><span class="p">(</span><span class="ss">:ClassMethods</span><span class="p">,</span> <span class="no">Module</span><span class="o">.</span><span class="n">new</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">mod</span><span class="o">.</span><span class="n">module_eval</span><span class="p">(</span><span class="o">&amp;</span><span class="n">class_methods_module_definition</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>其实这个东西跟前面的included方法原理差不多，也是通过代码块来收集方法，只是有一点点不同，</p>

<p>我们需要把这个收集到的代码块包裹到一个模块中，以后再扩展这个模块。</p>

<p>首先通过const_defined?来判断常量ClassMethods是否存在，</p>

<p>该方法的第二个参数false表示只从当前模块查找该常量，而不会从祖先链中去查找。</p>

<p>如果没有则以ClassMethods为名定义一个模块，</p>

<p>然后以Module#module_eval方法打开该模块并在模块的上下文运行我们所接收的代码块class_methods_module_definition。</p>

<p>这样模块ClassMethods就会包含对应的方法了。</p>

<p>在以后的日子里我们只需要扩展ClassMethods，该模块里面的方法就能成为目标模块的类方法了。</p>

<ol type="a">
<li>功能增强
收集完相关功能之后可以来看如何增强我们的终端模块了。在分析代码之前，</li>
</ol>


<p>先来认识一下append_features，我们需要知道的是它会在模块被包含的时候调用，并且它会在included回调方法之前被调用。</p>

<p>接下来我们看看扩展功能的源代码，它应该是ActiveSupport::Concern里面最复杂的方法了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">ActiveSupport::Concern</span>
</span><span class='line'>  <span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">.</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">append_features</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">base</span><span class="o">.</span><span class="n">instance_variable_defined?</span><span class="p">(</span><span class="ss">:@_dependencies</span><span class="p">)</span>
</span><span class='line'>      <span class="n">base</span><span class="o">.</span><span class="n">instance_variable_get</span><span class="p">(</span><span class="ss">:@_dependencies</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
</span><span class='line'>      <span class="k">return</span> <span class="kp">false</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="k">return</span> <span class="kp">false</span> <span class="k">if</span> <span class="n">base</span> <span class="o">&lt;</span> <span class="nb">self</span>
</span><span class='line'>      <span class="vi">@_dependencies</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">dep</span><span class="o">|</span> <span class="n">base</span><span class="o">.</span><span class="n">include</span><span class="p">(</span><span class="n">dep</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>      <span class="k">super</span>
</span><span class='line'>      <span class="n">base</span><span class="o">.</span><span class="n">extend</span> <span class="nb">const_get</span><span class="p">(</span><span class="ss">:ClassMethods</span><span class="p">)</span> <span class="k">if</span> <span class="nb">const_defined?</span><span class="p">(</span><span class="ss">:ClassMethods</span><span class="p">)</span>
</span><span class='line'>      <span class="n">base</span><span class="o">.</span><span class="n">class_eval</span><span class="p">(</span><span class="o">&amp;</span><span class="vi">@_included_block</span><span class="p">)</span> <span class="k">if</span> <span class="n">instance_variable_defined?</span><span class="p">(</span><span class="ss">:@_included_block</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在我们可以看到之前设置“胎记”起作用了，设置了“胎记”的依赖模块也可以被其他的依赖模块所包含，</p>

<p>但他们并不会进行相应的功能扩展，他们会做的只是在“胎记”列表@_dependencies里面添加对应的依赖选项。</p>

<p>然后返回false。这也是我们第一个条件分支的逻辑。
当我们的依赖模块终于被终端模块（不含“胎记”的模块）包含的时候我们程序便可以走else分支的逻辑。</p>

<p>如果该依赖模块已经在终端模块的祖先链中的话则表明这个模块已经在终端模块增强过了，我们就没必要做重复工作，直接返回false。</p>

<p>否则的话继续执行后面的代码，接下来这个语句有点意思
@_dependencies.each { |dep| base.include(dep) }</p>

<p>我们会以终端模块的身份去包含当前依赖模块的@_dependencies列表里面的所有模块，</p>

<p>这个时候我们@_dependencies的模块又会进入各自相应的append_features方法，并且都会走else分支，</p>

<p>然后查看各自@_dependencies接下来又会以终端模块的身份再去包含列表里的那些模块，</p>

<p>以此类推。这递归的过程就像是链式反应，这样就能保证不管各个依赖模块之间的依赖关系如何，</p>

<p>我们的终端模块都不用太过在意了，反正最后都会被我们终端模块给包含掉。</p>

<p>接下来调用super关键字来调用原始的append_features方法，保证了原始的功能。</p>

<p>毕竟我们这里做的是对原始功能加强，而并不是要复写掉原始功能。</p>

<p>最后我们在每一个依赖模块内部都会执行大家所熟悉的语句
base.extend const_get(:ClassMethods) if const_defined?(:ClassMethods)
base.class_eval(&amp;@<em>included_block) if instance_variable_defined?(:@</em>included_block)</p>

<p>最最最后，咱们的终端模块就会具备我们预先定义好的类方法，实例方法。</p>

<p>并且可以直接运行一些预先定义好需要在模块上下文运行的类方法了。</p>

<h3>优雅的Ruby</h3>

<p>源码分析暂时告一段落，为了让我们对ActiveSupport::Concern印象更加深刻一些。最后我用一个简单的例子来展示一下这个库的优雅之处</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;active_support&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="k">module</span> <span class="nn">A</span>
</span><span class='line'>  <span class="kp">extend</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Concern</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">included</span> <span class="k">do</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">number1</span>
</span><span class='line'>      <span class="s2">&quot;number1 method&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">class_methods</span> <span class="k">do</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">active1</span>
</span><span class='line'>      <span class="s2">&quot;active1 class method&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">module</span> <span class="nn">B</span>
</span><span class='line'>  <span class="kp">extend</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Concern</span>
</span><span class='line'>  <span class="kp">include</span> <span class="n">A</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">included</span> <span class="k">do</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">number2</span>
</span><span class='line'>      <span class="s2">&quot;number2 method&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">class_methods</span> <span class="k">do</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">active2</span>
</span><span class='line'>      <span class="s2">&quot;active2 class method&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">module</span> <span class="nn">C</span>
</span><span class='line'>  <span class="kp">extend</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Concern</span>
</span><span class='line'>  <span class="kp">include</span> <span class="n">B</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">included</span> <span class="k">do</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">number3</span>
</span><span class='line'>      <span class="s2">&quot;number3 method&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">number2</span>
</span><span class='line'>      <span class="s2">&quot;number2 in C&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">class_methods</span> <span class="k">do</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">active3</span>
</span><span class='line'>      <span class="s2">&quot;active3 class method&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">active2</span>
</span><span class='line'>      <span class="s2">&quot;active2 in C&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Example</span>
</span><span class='line'>  <span class="kp">include</span> <span class="n">C</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="nb">p</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">A</span><span class="o">.</span><span class="n">instance_variable_get</span><span class="p">(</span><span class="s2">&quot;@_dependencies&quot;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'><span class="nb">p</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">B</span><span class="o">.</span><span class="n">instance_variable_get</span><span class="p">(</span><span class="s2">&quot;@_dependencies&quot;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'><span class="nb">p</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">C</span><span class="o">.</span><span class="n">instance_variable_get</span><span class="p">(</span><span class="s2">&quot;@_dependencies&quot;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="nb">puts</span> <span class="no">Example</span><span class="o">.</span><span class="n">active3</span>
</span><span class='line'><span class="nb">puts</span> <span class="no">Example</span><span class="o">.</span><span class="n">active2</span>
</span><span class='line'><span class="nb">puts</span> <span class="no">Example</span><span class="o">.</span><span class="n">active1</span>
</span><span class='line'>
</span><span class='line'><span class="nb">puts</span> <span class="no">Example</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">number3</span>
</span><span class='line'><span class="nb">puts</span> <span class="no">Example</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">number2</span>
</span><span class='line'><span class="nb">puts</span> <span class="no">Example</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">number1</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后的打印结果是</p>

<blockquote><p>&ldquo;[]&rdquo; &ldquo;[A]&rdquo; &ldquo;[B]&rdquo;
active3 class method
active2 in C
active1 class method
number3 method
number2 in C
number1 method</p></blockquote>

<p>利用ActiveSupport::Concern我们可以用少量的代码，优雅地定义我们的扩展模块，并在需要的时候进行功能增强。</p>

<p>在该例子中我通过打印“胎记”可以知道依赖模块之间的依赖关系，</p>

<p>而且他们之间的依赖关系终端模块根本不会在意，它只需要包含一个依赖模块，</p>

<p>便可以得到有依赖关系其他依赖模块中所定义的功能了。</p>

<p>另外，我在模块C中做了些手脚，复写了它所依赖的模块B中所收集的方法，</p>

<p>是为了展示我们所收集方法在各个有依赖关系模块中的优先级关系。</p>
</div>
  
  


      <footer>
      
      - <a href="/blog/2019/11/27/railsde-activesupport-concern/">Railsçš„ActiveSupport::Concern</a>
      <time datetime="2019-11-27T18:47:49+08:00" pubdate><span class='month'>Nov</span> <span class='day'>27</span> <span class='year'>2019</span></time>
      
      <span class="categories">posted in <a class='category' href='/blog/categories/ruby/'>ruby</a></span>
      
      </footer>
    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2019/01/04/wen-ben-jian-mo-suan-fa-ru-men-1/">文本建模算法入门-1</a></h1>
    
    
      <div class="post-meta">
        <p class="meta">
          <span class="timestamp">- 








  



<time datetime="2019-01-04T13:43:27+08:00" pubdate data-updated="true"></time> -</span>
          
        </p>
      </div>
    
  </header>


  <div class="entry-content"><p>﻿<h1 id="文本建模算法入门一">文本建模算法入门（一）</h1></p>

<h3 id="0x1-文本建模">0x1 文本建模</h3>




<p>文本并不像其他数值型的数据一样可以比较轻易的通过运算、函数、方程、矩阵等来表达他们之间的相互关系。</p>




<p>在处理一篇文本的时候，假设每一个文本储存为一篇文档，那么从人的视角来看，这可以说是一段有序的词序列<script type="math/tex; mode=display" id="MathJax-Element-1">Document=(w_1,w_2,...,w_n)</script> <br>
统计学家将这些序列的生成，生动地描绘成了一个“上帝的游戏”，即人类产生的所有语料的文本都可以看作是：一个伟大的上帝在天堂中掷骰子形成的。我们所看到的文本其实就是这个游戏掷了若干次后产生的序列。</p>




<p>那么，在这个游戏中，我们<strong>最需要关注的两个核心问题</strong>就出现了：</p>




<ol>
<li>上帝有怎样的骰子？</li>
<li>上帝是怎么掷的骰子？</li>
</ol>




<p>对应这两个问题，各大学家持着不同的观点，于是便有了以下三种模型：</p>




<ol>
<li>Unigram Model</li>
<li>Topic Model(PLSA)</li>
<li>LDA</li>
</ol>




<h4 id="0x11-unigram-model">0x11 Unigram Model</h4>




<p>Unigram Model是非常简单直接的，它假设</p>




<ol>
<li>上帝只有一个V面的骰子，每一个面对应一个词，同时每个面的概率不一样。（这里可以通过“老千骰子”来理解下，有些面因为被做过了“手脚”，所以抛到的几率就大了，那如果没个面都这样，那么每个面抛到的几率也就不一样了）</li>
<li>每抛一次骰子，抛出的面就对应有一个词，那么抛n次骰子后，按抛掷顺序产生的序列就生成了一篇n个词的文档</li>
</ol>




<p><img src="https://ws1.sinaimg.cn/large/a3d23450gy1fyudrkxl14j2086052dg2.jpg" alt="enter image description here" title=""></p>




<p>那现在我们把上帝这个唯一的骰子各个面的概率记为<script type="math/tex" id="MathJax-Element-2">\vec{p}=\{p_1,p_2,...,p_v\}</script>，然后我们把掷这个V面骰子的实验记作<script type="math/tex" id="MathJax-Element-3">w \sim Mult(w|\vec{p}) </script></p>




<p>那么对应一篇文档d，该文档生成的概率就是 <br>
<script type="math/tex; mode=display" id="MathJax-Element-4">p(\vec{w})=p(w_1,w_2,...,w_n)=p(w_1)p(w_2)...p(w_n)</script></p>




<p>而文档和文档之间我们认为是独立的，所以如果语料中有多篇文档<script type="math/tex" id="MathJax-Element-5">W=(\vec{w_1},\vec{w_2},...,\vec{w_m})</script>，则该语料生成的概率就是<script type="math/tex; mode=display" id="MathJax-Element-6">p(W)=p(\vec{w_1})p(\vec{w_2})...p(\vec{w_m})</script></p>




<p>在Unigram Model中，我们又假设了文档之间是独立可交换的。即，词与词之间的顺序对文档表示并不造成影响，一篇文档相当于一个袋子，里面装着一些词。这样的模型也称为<strong>词袋模型（Bag-of-words）。</strong></p>




<p>那么，如果语料中的总词频是N，在N个词中，如果我们关注每一个词<script type="math/tex" id="MathJax-Element-7">w_i</script>的发生次数<script type="math/tex" id="MathJax-Element-8">n_i</script>，则<script type="math/tex" id="MathJax-Element-9">\vec{n}=(n_1,n_2,...,n_V)</script>正好是一个多项分布 <br>
<script type="math/tex; mode=display" id="MathJax-Element-10">p(\vec{n})=Mult(\vec{n}|\vec{p},N)</script> <br>
此时，语料的概率是 <br>
<script type="math/tex; mode=display" id="MathJax-Element-11">p(W)=p(\vec{w_1})p(\vec{w_2})...p(\vec{w_m})=\prod_{k=1}^Vp_k^{n_k}</script></p>




<h4 id="0x110-贝叶斯unigram-model假设">0x110 贝叶斯Unigram Model假设</h4>




<p>在贝叶斯统计学派看来，上帝拥有唯一一个固定的骰子是不合理的。于是他们觉得以上模型的骰子<script type="math/tex" id="MathJax-Element-12">\vec{p}</script>不应该唯一固定，而应该也是一个随机变量。</p>




<p>那这样我们就可以将整个掷骰子的游戏过程更新成以下形式：</p>




<ol>
<li>上帝有一个装着无穷多骰子的罐子，里面有各种骰子，每个骰子有V个面。每一个面对应一个词</li>
<li>上帝从罐子抽出一个骰子，然后用这个骰子不断的抛，每抛一次骰子，抛出的面就对应有一个词，那么抛n次骰子后，按抛掷顺序产生的序列就生成了一篇n个词的文档 <br>
<img src="https://ws1.sinaimg.cn/large/a3d23450gy1fyufvboyshj20a106cjs7.jpg" alt="enter image description here" title=""></li>
</ol>




<p>在以上的假设之下，由于我们事先并不知道上帝用了哪个骰子<script type="math/tex" id="MathJax-Element-13">\vec{p}</script>，所以每个骰子都是有可能被使用的，只是使用的概率由先验分布<script type="math/tex" id="MathJax-Element-14">p(\vec{p})</script>决定，对每一个具体的骰子<script type="math/tex" id="MathJax-Element-15">\vec{p}</script>，由该骰子产生数据的概率是<script type="math/tex" id="MathJax-Element-16">p(W|\vec{p})</script>，所以最终数据产生的概率就是对每个骰子上产生的数据概率进行积分累加求和 <br>
<script type="math/tex; mode=display" id="MathJax-Element-17">P(W)=\int p(W|\vec{p})p(\vec{p})d\vec{p}</script> <br>
在贝叶斯分析的框架之下，此处的先验分布概率其实就是一个多项分布的概率，其中一个比较好的选择即<strong>多项分布对应的共轭分布：Dirichlet分布</strong></p>




<h4 id="0x12-plsa-topic-model">0x12 PLSA Topic Model</h4>




<p>再来回顾Unigram Model我们发现：这个模型的假设过于简单，和人类真实的书写有着较大的差距</p>




<p>从人类视角看，我们在日常构思文章中，我们往往要先确定自己文章的主旨，包含了哪些主题，然后再围绕着这些主题展开阐述。</p>




<p>例如，一篇关于现代教育的文章，它可能就包含了这些主题：教育方法、多媒体技术、互联网等。篇幅上可能以教育方法为主，而其他为辅。然后，在不同的主题里面就包含了许多主题领域内常见的关键词。例如，谈到互联网时，我们会提及Web、Tcp等。</p>




<p>这样一种直观的想法就在<strong>PLSA模型中进行了明确的体现</strong>，如果我们再利用这个想法更新“掷骰子”的游戏就有以下情形：</p>




<ol>
<li>上帝有两种类型骰子，一类是doc-topic骰子，骰子共k个面代表了k个主题；一类是topic-word骰子，骰子V个面，每面对应主题内的一个词</li>
<li>生成文章的时候，首先要先创造一个特定的doc-topic骰子，使得骰子内的主题围绕文章要阐述的主题</li>
<li>投掷doc-topic骰子，得到一个主题z</li>
<li>根据得到的主题z，找到对应的topic-word骰子，投掷它得到一个词</li>
<li>不断重复3，4步，直至文章生成完成</li>
</ol>




<p><img src="https://ws1.sinaimg.cn/large/a3d23450gy1fyugrx9ybdj20a50810tj.jpg" alt="enter image description here" title=""></p>




<p>在上面的游戏规则中，文档与文档之间顺序无关，同一个文档内的词的顺序也是无关的。所以还是一个bag-of-words模型。</p>




<p>那么，在第m篇文档Dm中每个词的生成概率为： <br>
<script type="math/tex; mode=display" id="MathJax-Element-18">p(w|D_m)=\sum^K_{z=1}p(w|z)p(z|D_m)=\sum^K_{z=1}\phi_{zw_i}\theta_{dz}</script> <br>
<script type="math/tex" id="MathJax-Element-19">\phi_{zw_i}</script>:对应游戏中K个topic-word骰子中第z个骰子对应的词列表</p>




<p><script type="math/tex" id="MathJax-Element-20">\theta_{dz}</script>:文档对应的第z个主题，即对应的doc-topic</p>




<p>所以整篇文档的生成概率就为： <br>
<script type="math/tex; mode=display" id="MathJax-Element-21">p(w|D_m)=\prod^n_{i=1}\sum^K_{z=1}p(w_i|z)p(z|D_m)</script></p>




<h4 id="0x13-ldalatent-dirichlet-allocation">0x13 LDA(Latent Dirichlet Allocation)</h4>




<p>就像Unigram Model 加入贝叶斯框架那样，doc-topic和topic-word都是模型的参数，即随机变量。于是类似对Unigram Model的改造对以上两个骰子模型加入先验分布。然后由于<script type="math/tex" id="MathJax-Element-22">\vec{\theta}</script>，<script type="math/tex" id="MathJax-Element-23">\vec{\phi}</script>都对应着多项分布，因此先验分布依旧选择Drichlet分布。于是得到的这个新模型就是<strong>LDA(Latent Dirichlet Allocation)模型</strong> <br>
<img src="https://ws1.sinaimg.cn/large/a3d23450gy1fyuhfhrza5j20cx09bwgm.jpg" alt="enter image description here" title=""></p>




<p>在LDA模型中，上帝的游戏规则就又被更新成如下情形：</p>




<ol>
<li>上帝有两个罐子，第一个装着都哦doc-topic骰子，第二个装着topic-word骰子</li>
<li>上帝随机的从第二个罐子中独立抽出K个topic-doc骰子，编号1-K</li>
<li>每次生成新文档时，从第一个罐子随机抽一个doc-topic骰子</li>
<li>投掷得到的doc-topic骰子。得到一个主题编号z</li>
<li>在K个主题骰子里面选择编号为z的骰子，投掷骰子，得到一个词</li>
<li>重复4，5步，直至文档生成完成</li>
</ol>




<h3 id="0x2-后记">0x2 后记</h3>




<p>至此，入门篇（一）的内容就写到这了。由于是第一篇，文章中避过了许多较为复杂的数学证明和计算，尤其是关于LDA模型的。这样是为了，先建立对文本建模思路和过程的直观认识，而不是一上来就深究细节。</p>




<p>加上笔者目前也是在学习阶段，后面的细节再慢慢地一一补充，大家共同进步 !! <br>
                        \(^_^)/</p>

</div>
  
  


      <footer>
      
      - <a href="/blog/2019/01/04/wen-ben-jian-mo-suan-fa-ru-men-1/">文本建模算法入门-1</a>
      <time datetime="2019-01-04T13:43:27+08:00" pubdate><span class='month'>Jan</span> <span class='day'>04</span> <span class='year'>2019</span></time>
      
      <span class="categories">posted in <a class='category' href='/blog/categories/tong-ji-xue-xi/'>统计学习</a></span>
      
      </footer>
    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2018/06/01/slamde-fu-xing-wu-ren-jia-shi-de-wei-lai/">SLAM的复兴-无人驾驶的未来?</a></h1>
    
    
      <div class="post-meta">
        <p class="meta">
          <span class="timestamp">- 








  



<time datetime="2018-06-01T20:09:15+08:00" pubdate data-updated="true"></time> -</span>
          
        </p>
      </div>
    
  </header>


  <div class="entry-content"><h2 id="slam的前世今生">SLAM的前世今生</h2>




<p>SLAM，全称(simultaneous localization and mapping)，中文译做，即时定位与地图构建。是指运动物体根据传感器的信息，一边计算自身位置，一边构建环境地图的过程，解决机器人等在未知环境下运动时的定位与地图构建问题。目前，SLAM的主要应用于机器人、无人机、无人驾驶、AR、VR等领域。其用途包括传感器自身的定位，以及后续的路径规划、运动性能、场景理解。 </p>




<p>作为一种基础技术，最早可以追溯到当初的军事潜艇定位技术。而今年来随着扫地机器人的盛行，再次令他名声大噪。加上最近的无人驾驶与机器人的寻迹的崛起以及基于三维视觉的VSLAM的出现又让它越来越显主流。</p>




<p>目前用在SLAM上的Sensor主要分两大类，分别是激光雷达和摄像头。</p>




<h2 id="slam到底做了些什么">SLAM到底做了些什么?</h2>




<p>既然SLAM技术代表了即时定位与地图构建，那么可以说这就是一个机器人或设备尝试去根据他周围的环境创建地图的过程，并且还可以在该地图中实时定位自己。</p>




<p>这不是一件容易的事，这项技术现在还处在技术研究和设计的前沿。而为了成功实施SLAM有一大障碍是不可i避免的，那就是<strong>地图</strong>和<strong>定位</strong>问题，两个问题同时引入就变成了我们常说的典型的<strong>鸡与蛋</strong>问题。为了能够成功地顺利的根据环境创建地图，我们的设备就必须先知道它的方向和位置 ;然而，这些定位信息设备也只能从预先存在的环境地图中获得。</p>




<p>面对这一障碍，SLAM技术通常通过使用GPS数据构建预先存在的环境地图来克服这一复杂的鸡与蛋问题。随着机器人或设备在环境中移动，生成的地图会被迭代地改进。而这项技术的真正挑战是准确性。随着机器人或设备在空间中移动与寻迹，测量评估必须不断进行，并且该技术必须考虑设备移动和测量方法不准确而引起的“噪音”。</p>




<p><img src="https://i.loli.net/2018/06/01/5b11319dab704.gif" alt="enter image description here" title=""></p>




<p>这个gif是宾大的教授kumar做的特别有名的一个demo，是在无人机上利用二维激光雷达做的SLAM。</p>




<h2 id="vslam又是什么">VSLAM又是什么?</h2>




<p>VSLAM（基于视觉的定位与建图）：随着计算机视觉的迅速发展，视觉SLAM因为信息量大，适用范围广等优点受到广泛关注。</p>




<p>（1）基于深度摄像机的Vslam，跟激光SLAM类似，通过收集到的点云数据，能直接计算障碍物距离；</p>




<p>（2）基于单目、鱼眼相机的VSLAM方案，利用多帧图像来估计自身的位姿变化，再通过累计位姿变化来计算距离物体的距离，并进行定位与地图构建；</p>




<p><img src="https://i.loli.net/2018/06/01/5b1131954cc50.gif" alt="enter image description here" title=""></p>




<p>以上为百度 VSLAM demo展示。</p>




<h2 id="vslam能够为自动驾驶带来些什么">VSLAM能够为自动驾驶带来些什么?</h2>




<p>结合自动驾驶的场景，可以推出VSLAM的应用点主要是:</p>




<ul>
<li>gps缺失场景下的长时间定位，如室内，楼房中。</li>
<li>补偿行驶过程中gps信号不稳定造成的定位跳跃，如山洞，高楼群，野外山区等。</li>
</ul>




<p>VSLAM的精度及鲁棒性越高，适用的场景越宽广。如果VSLAM能在任何场景无限长定位保持高精度，那其他定位技术就可以下岗了，虽然按目前看来这个可能性很小，因此需要尝试结合IMU，编码器等设备融合。至于最终的技术形态，目前还没有定论。</p>




<p>在无人驾驶汽车上，目前比较显著的瓶颈还在计算方面，数据收发，障碍物感知，融合定位，路径规划，每个模块都需要占据相当的计算资源。而无论视觉还是激光SLAM本身就是对计算力消耗极大的一个模块，如果加上高频率的IMU进行融合优化，则计算力更加捉襟见肘。因此是否值得为视觉SLAM分配原本就那么有限的计算资源，如何识别场景对SLAM模块进行激活都是需要仔细衡量的。</p>

</div>
  
  


      <footer>
      
      - <a href="/blog/2018/06/01/slamde-fu-xing-wu-ren-jia-shi-de-wei-lai/">SLAM的复兴-无人驾驶的未来?</a>
      <time datetime="2018-06-01T20:09:15+08:00" pubdate><span class='month'>Jun</span> <span class='day'>01</span> <span class='year'>2018</span></time>
      
      <span class="categories">posted in <a class='category' href='/blog/categories/ke-ji-zi-xun/'>科技资讯</a></span>
      
      </footer>
    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2018/05/30/wo-de-suan-fa-tian-ti-zhi-lu-zhi-qiong-ju-sou-suo/">我的算法天梯之路之-穷举搜索</a></h1>
    
    
      <div class="post-meta">
        <p class="meta">
          <span class="timestamp">- 








  



<time datetime="2018-05-30T22:15:17+08:00" pubdate data-updated="true"></time> -</span>
          
        </p>
      </div>
    
  </header>


  <div class="entry-content"><h2 id="穷举搜索的例子google方程式">穷举搜索的例子－Google方程式</h2>




<h3 id="问题描述">　问题描述</h3>




<p>有一个由字符组成的等式，WWWDOT-GOOGLE = DOTCOM，每个字符代表一个0-9之间的数字，WWWDOT、GOOGLE和DOTCOM都是合法的数字，不能以零开头。请找出一组字符与数字的对应关系，使得他们可以互相转换，并且替换之后能够满足等式。</p>




<h3 id="问题分析">问题分析</h3>




<p>从排列组合的角度来看，这道题是一道典型的排列组合问题，题目中一共出现了9个字母。</p>




<p>如果不考虑0开头的情况下，这样的组合应该有10x9x8x7x6x5x4x3x2=3628800种组合。</p>




<p>在这样的情况之下，计算机的穷举处理应该是毫无压力的。</p>




<h3 id="问题求解">问题求解</h3>




<p>首先为了能够表示这样一种可变的字符元素列表，我们需要自定义一种数据结构。首先我们知道这个自定义结构中应该包含有三个属性，分别是 字符本身，字符代表的数字以及是否为数字的最高位，因为最高位是不能为0的，所以在这里我们要区别对待。</p>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">tagCharItem</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="n">leading</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="n">CHAR_ITEM</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>




<p>接着我们初始化这个列表。=</p>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">CHAR_ITEM</span> <span class="n">charItem</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span>
</span><span class='line'><span class="p">{</span><span class="sc">&#39;W&#39;</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nb">true</span><span class="p">},{</span><span class="sc">&#39;D&#39;</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nb">true</span><span class="p">},{</span><span class="sc">&#39;O&#39;</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nb">true</span><span class="p">},</span>
</span><span class='line'><span class="p">{</span><span class="sc">&#39;T&#39;</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nb">false</span><span class="p">},{</span><span class="sc">&#39;G&#39;</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nb">true</span><span class="p">},{</span><span class="sc">&#39;L&#39;</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nb">false</span><span class="p">},</span>
</span><span class='line'><span class="p">{</span><span class="sc">&#39;E&#39;</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nb">false</span><span class="p">},{</span><span class="sc">&#39;C&#39;</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nb">false</span><span class="p">},{</span><span class="sc">&#39;M&#39;</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nb">false</span><span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>因为这是一个组合问题，那么两个字母就不能被指定为相同的数字，这样我们需要定义额外的占用标识。</p>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">tagCharValue</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="n">isused</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="n">CHAR_VALUE</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//穷举算法实现如下</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">SearchingResult</span><span class="p">(</span><span class="n">CHAR_ITEM</span> <span class="n">ci</span><span class="p">[],</span><span class="n">CHAR_VALUE</span> <span class="n">cv</span><span class="p">[],</span>
</span><span class='line'><span class="kt">int</span> <span class="n">index</span><span class="p">,</span><span class="n">CharListReadyFuncPtr</span> <span class="n">callback</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">max_char_count</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">callback</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">max_number_count</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">IsValueValid</span><span class="p">(</span><span class="n">ci</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="n">cv</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">cv</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">isused</span><span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'>      <span class="n">ci</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">value</span> <span class="o">=</span> <span class="n">cv</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">value</span><span class="p">;</span>
</span><span class='line'>      <span class="n">SearchingResult</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="n">cv</span><span class="p">,</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">callback</span><span class="p">);</span>
</span><span class='line'>      <span class="n">cv</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">isused</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<p>根据题目要求，W，G，D三者都不能为0，为了加快穷举速度可以对他们为0的情况进行剪枝。 <br>
IsValueValid是评估函数，在剪枝操作之后，callback的被调用次数可以减少约30%。</p>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">//callback代码实现</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">OnCharListReady</span><span class="p">(</span><span class="n">CHAR_ITEM</span> <span class="n">ci</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span> <span class="n">minuend</span> <span class="o">=</span> <span class="s">&quot;WWWDOT&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span> <span class="n">subtrahend</span> <span class="o">=</span> <span class="s">&quot;GOOGLE&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span> <span class="n">diff</span> <span class="o">=</span> <span class="s">&quot;DOTCOM&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">MakeIntegerValue</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="n">minuend</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">MakeIntegerValue</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="n">subtrahend</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">MakeIntegerValue</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="n">diff</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span><span class="p">((</span><span class="n">m</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">==</span><span class="n">d</span><span class="p">){</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;-&quot;</span> <span class="o">&lt;&lt;</span><span class="n">s</span><span class="o">&lt;&lt;</span> <span class="s">&quot;=&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<blockquote>
  <p>问题答案 <br>
  777589 - 188103 = 589486 <br>
  777589 - 188106 = 589483</p>
</blockquote>

</div>
  
  


      <footer>
      
      - <a href="/blog/2018/05/30/wo-de-suan-fa-tian-ti-zhi-lu-zhi-qiong-ju-sou-suo/">我的算法天梯之路之-穷举搜索</a>
      <time datetime="2018-05-30T22:15:17+08:00" pubdate><span class='month'>May</span> <span class='day'>30</span> <span class='year'>2018</span></time>
      
      <span class="categories">posted in <a class='category' href='/blog/categories/suan-fa-bi-ji/'>算法笔记</a></span>
      
      </footer>
    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2018/03/10/yin-ma-er-ke-fu-mo-xing-(hmm)de-yuan-li/">隐马尔可夫模型（HMM）的原理</a></h1>
    
    
      <div class="post-meta">
        <p class="meta">
          <span class="timestamp">- 








  



<time datetime="2018-03-10T08:48:21+08:00" pubdate data-updated="true"></time> -</span>
          
        </p>
      </div>
    
  </header>


  <div class="entry-content"><p>﻿<h1 id="隐马尔可夫模型hmm的原理">隐马尔可夫模型（HMM）的原理</h1></p>

<h2 id="简介">简介</h2>




<p>隐马尔可夫模型是一个基于<a href="https://en.wikipedia.org/wiki/Markov_chain">马尔可夫链</a>的统计模型。</p>




<p><strong>马尔可夫链</strong>因<a href="http://wiki.mbalib.com/wiki/%E5%AE%89%E5%BE%B7%E7%83%88%C2%B7%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB">安德烈·马尔可夫（Andrey Markov，1856－1922）</a>得名，是数学中具有马尔可夫性质的离散时间随机过程。该过程中，在给定当前知识或信息的情况下，过去（即当期以前的历史状态）对于预测将来（即当期以后的未来状态）是无关的。</p>




<p>虽然从维基百科上摘取下来的概念和定义看着十分的晦涩难懂，但是模型背后的思想是非常简单的，即：首先假设你的系统可以建模为马尔可夫链，然后，系统所发出的信号（输出的可见结果）仅取决于系统当前的状态。那么，隐马尔可夫模型代表的一种情景就是：系统的状态对你而言是不可见的，你仅仅只能观测到系统所发出的信号或者说是系统所输出的结果。</p>




<p>举个通俗易懂的栗子。</p>




<p>假设你有一个住在国外的朋友，他通常会根据天气来安排他的日常活动。你不知道他的国家那边的天气如何（系统的状态），但你确可以在跟他的聊天中知道他今天进行了什么活动（系统的输出），然后这就是一个简单的隐马尔可夫模型。</p>




<p>我们将整个模型 <br>
<img src="https://i.loli.net/2017/09/10/59b49b5275c1d.jpg" alt="markov.jpg" title=""></p>




<p>现在有三个比较关键的问题有待我们解决： <br>
1.  知道整个模型后，你朋友告诉你他这三天的活动是：散步（Walk），购物（Shop），清洁屋子（Clean），那么根据模型，计算产生这些行为序列的概率是多少？ <br>
2. 知道整个模型后，朋友让你根据他的活动猜一猜他那边这三天天气怎么样 <br>
3. 朋友告诉你三天里他做了些什么，然后让你找出他活动规律的模型。</p>




<p>为了解决以上的问题我们首先要了解一些有关HMM的基本元素先：</p>




<p><strong>初始概率分布<script type="math/tex" id="MathJax-Element-5">\pi</script></strong>：初始概率分布即事件初始时发生的概率，我们这里隐藏的状态是天气，然后我们在图中可以看出的初始概率有：天气为晴天的概率为0.8 ; 天气为雨天的概率为0.2</p>




<p><strong>转移概率矩阵P</strong>：转移功率矩阵就可以通过一副图来描述了。</p>




<table>
<thead>
<tr>
  <th>晴天</th>
  <th>雨天</th>
</tr>
</thead>
<tbody><tr>
  <td>晴天</td>
  <td>0.7</td>
</tr>
<tr>
  <td>雨天</td>
  <td>0.6</td>
</tr>
</tbody></table>




<p>其中，列参数表示第一天的状态，行参数表示第二天状态。表格中的第一行的含义就是已知第一天为晴天，那么第二天为晴天的概率是0.7，而为雨天的概率只是0.3。</p>




<p><strong>观测量的概率分布B</strong>：在这个问题中观测量就是朋友的活动，其概率分布就分别表示为朋友在晴天和雨天的情况下进行散步，购物，打扫屋子各项活动的可能性（概率）。</p>




<p>现在，我们再次回到上面提到的三个问题。其实，每个问题的解决解决在历史上早有前人给出了算法。</p>




<blockquote>
  <p>问题1 -&gt; <a href="https://en.wikipedia.org/wiki/Forward_algorithm">Forward Algorithm</a>，向前算法 或 <a href="https://en.wikipedia.org/wiki/Forward%E2%80%93backward_algorithm">Backward Algorithm</a>，向后算法。</p>
  
  <p>问题2 -&gt; <a href="https://en.wikipedia.org/wiki/Viterbi_algorithm">Viterbi Algorithm</a>，维特比算法。</p>
  
  <p>问题3 -&gt; <a href="https://en.wikipedia.org/wiki/Baum%E2%80%93Welch_algorithm">Baum-Welch Algorithm</a>，鲍姆-维尔奇算法。</p>
</blockquote>




<h2 id="算法思路">算法思路</h2>




<p><strong>假设前提：</strong> <br>
已知，雨天，朋友选择去散步，购物，收拾的概率分别是0.1，0.4，0.5， 而如果是晴天，选择去散步，购物，收拾的概率分别是0.6，0.3，0.1。 <br>
三天活动序列：散步（Walk），购物（Shop），清洁屋子（Clean）</p>




<h3 id="forward-algorithm">Forward Algorithm</h3>




<p>然后我们先计算 t = 1 时，发生 “散步” 行为的概率，如果下雨，则<script type="math/tex" id="MathJax-Element-6">P(Walk,Rain) = P_{t=1}(Rain) * P(Walk|Rain) = 0.2 \times 0.1 = 0.02</script>；如果为晴天，则<script type="math/tex" id="MathJax-Element-7">P(Walk,Sunny) = 0.8 \times 0.6 = 0.48</script></p>




<p>t = 2 时，发生 “购物” 的概率，如果 t = 2 下雨，则<script type="math/tex" id="MathJax-Element-8">P(Walk_{t=1},Shop_{t=2},Rain_{t=2}) = [P(Walk_{t=1},Rain_{t=1}) \times P(Rain_{t=2}|Rain_{t=1}) \\ + P(Walk_{t=1},Sunny_{t=1})\times P(Rain_{t=2}|Sunny_{t=1})]\times P(Shop_{t=2}|Rain_{t=2}) \\ = [0.02*0.4+0.48*0.3]*0.4 = 0.0608 </script></p>




<p>如果为晴天，则</p>




<p><script type="math/tex" id="MathJax-Element-9">P(Walk_{t=1},Shop_{t=2},Sunny_{t=2}) = [0.02*0.6 +0.48*0.7]*0.3 = 0.1044</script></p>




<p>t = 3 时的算法也可以依此类推， <br>
<script type="math/tex" id="MathJax-Element-10">P(Walk_{t=1},Shop_{t=2},Clean_{t=3},Rain_{t=3}) = [0.0608*0.4+0.1044*0.3]*0.5 = 0.02782</script>； <br>
<script type="math/tex" id="MathJax-Element-11">P(Walk_{t=1},Shop_{t=2},Clean_{t=3},Sunny_{t=3}) = [0.0608*0.6+0.1044*0.7]*0.7 = 0.076692</script></p>




<p>所以，最终： <br>
<script type="math/tex" id="MathJax-Element-12">P(Walk_{t=1},Shop_{t=2},Clean_{t=3}) = 0.02782 + 0.076692 = 0.104512</script></p>




<p>从上面的例子可以看出，向前算法计算了每个时间点时，每个状态的发生观测序列的概率，看似复杂，但在T变大时，复杂度也会随之降低。</p>




<h3 id="backward-algorihm">Backward Algorihm</h3>




<p>既然，向前算法是在时间 t = 1 的时候，一步一步向前计算。那么反过来，向后算法就是从最后一个状态往前推。 <br>
假设最初时<script type="math/tex" id="MathJax-Element-13">\beta_3(Rain) = 1；\beta_3(Sunny) = 1</script></p>




<p>那么：</p>




<p><script type="math/tex" id="MathJax-Element-14">\beta_2(Rain) = a_{Rain \to Rain}b_{Rain}(O_3=Clean)\beta_3(Rain) \\+ a_{Rain \to Sunny}b_{Sunny}(O_3=Clean)\beta_3(Sunny)\\=0.4*0.5*1+0.6*0.1*1 = 0.26</script> <br>
其中第一项则是转移概率，第二天下雨转到第三天下雨的概率为0.4；第二项则是观测概率，第三天下雨的状况下，在家收拾的概率为0.5；第三项就是我们定义的向后变量（backward variable）。</p>




<p>同理也可推得其他数据，并且最终答案与向前算法的求解相同。</p>




<h3 id="viterbi-algorithm维比特算法">Viterbi Algorithm（维比特算法）</h3>




<p>利用动态规划求解概率最大的路径（最优路径）。利用动态规划，可以解决任何一个图中的最短路径问题。而维特比算法是针对一个特殊的图——<strong>篱笆网络的有向图（Lattice）</strong>的最短路径提出的。</p>




<p>我们假设用符号<script type="math/tex" id="MathJax-Element-15">x_{ij}</script>来表示系统的第 i 种状态<script type="math/tex" id="MathJax-Element-16">x_i</script>的第j个可能的值。如果把每个状态按照不同的值展开，就可以得到以下的篱笆网络（Lattice）：</p>




<p><img src="https://i.loli.net/2017/09/10/59b4e956e6a56.png" alt="lattice.png" title=""></p>




<p>那么从第一个状态到最后一个状态的任何一条路径（path）都可能产生我们观察到的输出序列Y。当然，这些路径的可能性不一样，而我们要做的就是找到最可能的这条路径。对于每一条给定的路径我们都可以用公式:</p>




<p><script type="math/tex" id="MathJax-Element-17">x_1,x_2,...,x_N = \text{ArgMax}\left[P\left(x_1,x_2,...,x_N|y_1,y_2,...,y_N\right)\right(x \in X)]\\=\text{ArgMax}\left[\prod _{i=1}^N P\left(x_i|x_{i-1}\right)P\left(y_i|x_i\right)\right (x \in X)]</script></p>




<p>计算出它的可能性，但是随着组合增多，它使得序列状态数的增长呈指数爆炸式。</p>




<p>为了解决这个问题，需要一个最好能和状态数成正比的算法。也就是我们要讲的维特比算法。</p>




<p>维特比算法的基础可以概括成三点：</p>




<ol>
<li><p>如果概率最大的路径P（或者说最优路径）经过某个点，如果上图中的<script type="math/tex" id="MathJax-Element-18">x_{22}</script>，那么这条路径上从起始点S 到 <script type="math/tex" id="MathJax-Element-19">x_{22}</script>的这一段子路径Q，一定是S到<script type="math/tex" id="MathJax-Element-20">x_{22}</script>的最短路径。否则用S到<script type="math/tex" id="MathJax-Element-21">x_{22}</script>的最短路径R来代替Q，便构成了一条比P更短的路径。</p></li>
<li><p>从S到E的路径必定经过第i个时刻的某个状态，假定第i个时刻有k个状态，那么如果记录了从S到第i个状态的所以k个节点的最短路径，最终最短路径必经过其中的一条。这样，在任何时刻，只要考虑非常有限条最短路径即可。</p></li>
<li><p>结合上述两点，假定当我们从状态 i 进入状态 i + 1 时，从 S 到状态 i 上各个节点的最短路径已经找到，并且记录在这些节点上，那么在计算从起点 S 到第 i + 1 状态的某个节点<script type="math/tex" id="MathJax-Element-22">x_{i+1}</script>的最短路径时，只要考虑从S到前一个状态 i 所有的 k 个节点的最短路径，以及从这 k 个节点到<script type="math/tex" id="MathJax-Element-23">x_{i+1}</script>，j 的距离即可。</p></li>
</ol>




<h4 id="实现过程">实现过程</h4>




<ol>
<li>从点S出发，对于第一个状态<script type="math/tex" id="MathJax-Element-24">x_1</script>的各个节点，不妨假定有<script type="math/tex" id="MathJax-Element-25">n_1</script>个。计算出 S 到它们的距离<script type="math/tex" id="MathJax-Element-26">d(S，x_{1i})</script>,其中<script type="math/tex" id="MathJax-Element-27">x_{1i}</script>代表任意状态 1 的节点。因为只有一步，所以这些距离都是S到它们各自的最短距离。</li>
<li>对于第二个状态<script type="math/tex" id="MathJax-Element-28">x_2</script>的所有节点，要计算出从S到它们的最短距离。我们知道，对于特定的节点<script type="math/tex" id="MathJax-Element-29">x_{2i}</script>，从S到它的路径可以经过状态1的<script type="math/tex" id="MathJax-Element-30">n_1</script>中任何一个节点<script type="math/tex" id="MathJax-Element-31">x_{1i}</script>，当然，对应的路径长度就是<script type="math/tex" id="MathJax-Element-32">d(S,x_{2i}) = d(S,x_{1j})  + d(x_{1j},x_{2j})</script>。由于 j 有<script type="math/tex" id="MathJax-Element-33">n_1</script>种可能性，我们要一一计算，然后找到最小值。即：<script type="math/tex" id="MathJax-Element-34">d(S,x_{2i}) = min_{i=1,n_1}d(S,x_{1j})  + d(x_{1j},x_{2j})</script></li>
<li>这样对于第二状态的每个节点，需要<script type="math/tex" id="MathJax-Element-35">n_1</script>次乘法计算。假定这个状态有<script type="math/tex" id="MathJax-Element-36">n_2</script>个节点，把S这些节点的距离都算一遍，就有<script type="math/tex" id="MathJax-Element-37">O(n_1 * n_2)</script>次计算。</li>
</ol>




<p>接下来，类似地按照上述方法从第二个状态走到第三个状态，一直走到最后一个状态，就得到了整个网格从头到尾的最短路径。每一步计算的复杂度都和相邻两个状态<script type="math/tex" id="MathJax-Element-38">S_i和S_{i+1}</script>各自的节点数目<script type="math/tex" id="MathJax-Element-39">n_i，n_{i+1}</script>的乘积成正比，即<script type="math/tex" id="MathJax-Element-40">O(n_i,n_{i+1})</script>。如果假定在这个隐含马尔可夫链中的节点最多的状态有D个节点，也就是说整个网络的宽度为D，那么任何一布的复杂度不超过<script type="math/tex" id="MathJax-Element-41">O(D^2)</script>,由于网络长度是N，所以整个维特比算法的复杂度是<script type="math/tex" id="MathJax-Element-42">O(N*D^2)</script> ——本段推理节选自<a href="https://www.amazon.cn/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E-%E5%90%B4%E5%86%9B/dp/B00P6OJ09C/ref=cm_cr_arp_d_product_top?ie=UTF8">&lt;&lt;数学之美&gt;&gt;第二版</a></p>

</div>
  
  


      <footer>
      
      - <a href="/blog/2018/03/10/yin-ma-er-ke-fu-mo-xing-(hmm)de-yuan-li/">隐马尔可夫模型（HMM）的原理</a>
      <time datetime="2018-03-10T08:48:21+08:00" pubdate><span class='month'>Mar</span> <span class='day'>10</span> <span class='year'>2018</span></time>
      
      <span class="categories">posted in <a class='category' href='/blog/categories/tong-ji-xue-xi/'>统计学习</a></span>
      
      </footer>
    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/archives">Blog Archives</a>
    
  </div><!-- /div.pagination -->
</div><!-- /div.blog-index -->

      </div><!-- /div#content -->
    </div><!-- /div#main -->
  </div><!-- /div.container -->
  <footer><div id="footer-widgets-wrapper">
  <div id="footer-first" class="footer-widget">
    <h3>About Me</h3>
    <section class="about-me">
      
        <img class="icon-image" src="https://avatars0.githubusercontent.com/u/13914416?s=240" alt="icon_image">
      
      <div>
        <ul>
          
            <li>GitHub: <a href="https://github.com/EdmondFrank">@EdmondFrank</a></li>
          
          
            <li>Twitter: <a href="https://twitter.com/EdmondFrank4">@EdmondFrank4</a></li>
          
            <li>Blog: <a href="https://edmondfrank.github.io">https://edmondfrank.github.io</a></li>
        </ul>
        <p>
          この町、冗談と気まぐれと偶然でてきっているらしい。
        </p>
      </div>
    </section>
  </div><!-- /div#footer-second -->

  <div id="footer-second" class="footer-widget">
    <h3>Recent Posts</h3>
    <section id="hatena-popular" class="hatena-bookmark">
      <script language="javascript" type="text/javascript" src="https://b.hatena.ne.jp/js/widget.js" charset="utf-8"></script>
      <script language="javascript" type="text/javascript">
        Hatena.BookmarkWidget.url   = "https://edmondfrank.github.io";
        Hatena.BookmarkWidget.title = "Recent Posts";
        Hatena.BookmarkWidget.sort  = "hot";
        Hatena.BookmarkWidget.width = 0;
        Hatena.BookmarkWidget.num   = 10;
        Hatena.BookmarkWidget.theme = "notheme";
        Hatena.BookmarkWidget.load();
      </script>
    </section>
  </div><!-- /div#footer-second -->

  <div id="footer-third" class="footer-widget">
    <h3>Popular Posts</h3>
    <section id="hatena-popular" class="hatena-bookmark">
      <script language="javascript" type="text/javascript" src="https://b.hatena.ne.jp/js/widget.js" charset="utf-8"></script>
      <script language="javascript" type="text/javascript">
        Hatena.BookmarkWidget.url   = "https://edmondfrank.github.io";
        Hatena.BookmarkWidget.title = "Popular Posts";
        Hatena.BookmarkWidget.sort  = "count";
        Hatena.BookmarkWidget.width = 0;
        Hatena.BookmarkWidget.num   = 10;
        Hatena.BookmarkWidget.theme = "notheme";
        Hatena.BookmarkWidget.load();
      </script>
    </section>
  </div><!-- /div#footer-third -->
</div><!-- /div#footer-widgets-wrapper -->

<div id="credit" role="contentinfo">
  <p>
    Copyright &copy; 2020 - <a href="https://github.com/EdmondFrank/">EdmondFrank</a> -
    <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  </p>
</div>

</footer>
  










  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'https://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
