<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 算法,linux，cpp | EdmondFrank's 时光足迹]]></title>
  <link href="http://edmondfrank.github.io/blog/categories/suan-fa-linux,cpp/atom.xml" rel="self"/>
  <link href="http://edmondfrank.github.io/"/>
  <updated>2017-05-12T19:37:52+08:00</updated>
  <id>http://edmondfrank.github.io/</id>
  <author>
    <name><![CDATA[EdmondFrank]]></name>
    <email><![CDATA[EdmomdFrank@yahoo.co.jp]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[计算编辑距离(Levenshtein距离)]]></title>
    <link href="http://edmondfrank.github.io/blog/2017/03/22/ji-suan-bian-ji-ju-chi-levenshteinju-chi/"/>
    <updated>2017-03-22T17:33:02+08:00</updated>
    <id>http://edmondfrank.github.io/blog/2017/03/22/ji-suan-bian-ji-ju-chi-levenshteinju-chi</id>
    <content type="html"><![CDATA[<h1>计算字符串的相似度（编辑距离）</h1>

<h2>Levenshtein 距离</h2>

<p>Levenshtein距离，又称编辑距离，指的是两个字符串之间，由一个转换成另外一个所需的最少编辑量。
编辑距离算法首先由俄国科学家Levenshstance提出，原理可大致举例如下：</p>

<blockquote><p>字符串A：abcdefg
字符串B：abcdef</p></blockquote>

<p>以上两串字符串可以通过添加或是删除字符“g”的方式达到一致的目的。这两种方案都需要一次操作。</p>

<h2>算法实现</h2>

<p>此问题可以采用经典的动态规划求解。</p>

<h2>计算两字符串的最长公共子序列相似</h2>

<p>设Ai为字符串A(a1a2a3 … am)的前i个字符（即为a1,a2,a3 … ai）
设Bj为字符串B(b1b2b3 … bn)的前j个字符（即为b1,b2,b3 … bj）</p>

<p>设 L(i,j)为使两个字符串和Ai和Bj相等的最小操作次数。
当ai==bj时 显然</p>

<blockquote><p>L(i,j) = L(i-1,j-1)</p></blockquote>

<p>当ai!=bj时</p>

<blockquote><p>若将它们修改为相等，则对两个字符串至少还要操作L(i-1,j-1)次
若删除ai或在bj后添加ai，则对两个字符串至少还要操作L(i-1,j)次
若删除bj或在ai后添加bj，则对两个字符串至少还要操作L(i,j-1)次
此时L(i,j) = min( L(i-1,j-1), L(i-1,j), L(i,j-1) ) + 1</p></blockquote>

<p>所以，L(i,0)=i，L(0,j)=j, 再利用上述的递推公式，可以直接计算出L(i,j)值。</p>

<p>算法实现：
```cpp</p>

<h1>include <iostream></h1>

<h1>include <string></h1>

<p>using namespace std;
int calcdistance(string,string);
int minvalue(int,int,int);
int main(int argc, char *argv[])
{
    string str1 ,str2;
    cout&lt;&lt;&ldquo;Please input 2 strings:&rdquo;&lt;&lt;endl;
    cin>>str1>>str2;
    cout&lt;&lt;str1&lt;&lt;endl;
    cout&lt;&lt;str2&lt;&lt;endl;
    cout&lt;&lt;calcdistance(str1,str2)&lt;&lt;endl;
    //cout &lt;&lt; &ldquo;Hello World!&rdquo; &lt;&lt; endl;
    return 0;
}
int calcdistance(string s1, string s2)
{
    int len1 = s1.size()+1;
    int len2 = s2.size()+1;
    if(len1==0)
        return len2;
    if(len2==0)
        return len1;</p>

<pre><code>int ** cnt = new int*[len1];
for(int i=0;i&lt;len1;i++)
    cnt[i]=new int[len2];

for(int i=0;i&lt;len1;i++)cnt[i][0]=i;
for(int j=0;j&lt;len2;j++)cnt[0][j]=j;
//cnt[0][0] = 0;

for(int i=1;i&lt;len1;i++)
{
    for(int j=1;j&lt;len2;j++){
        if(s1[i-1]==s2[j-1])
            cnt[i][j]=cnt[i-1][j-1];
        else
        {
            cnt[i][j]=minvalue(cnt[i-1][j-1],
                    cnt[i-1][j],
                    cnt[i][j-1])+1;
        }
    }
}
int ret = cnt[len1-1][len2-1];
for(int i=0;i&lt;len1;i++)
    delete [] cnt[i];
delete [] cnt;
return ret;
</code></pre>

<p>}
int minvalue(int a, int b, int c){
 int t = a &lt;=b ? a : b;
 return t &lt;= c? t : c;
}
<code>
Vector版本如下：
</code>cpp</p>

<h1>include <iostream></h1>

<h1>include <string></h1>

<h1>include <vector></h1>

<p>using namespace std;
int calcdistance(string,string);
int main(int argc, char *argv[])
{
    string str1 ,str2;
    cout&lt;&lt;&ldquo;Please input 2 strings:&rdquo;&lt;&lt;endl;
    cin>>str1>>str2;
    cout&lt;&lt;str1&lt;&lt;endl;
    cout&lt;&lt;str2&lt;&lt;endl;
    cout&lt;&lt;calcdistance(str1,str2)&lt;&lt;endl;
    //cout &lt;&lt; &ldquo;Hello World!&rdquo; &lt;&lt; endl;
    return 0;
}
int calcdistance(string str1,string str2)
{
    int n = str1.size();
    int m = str2.size();
    if ( n == 0)
        return m;
    if ( m == 0)
        return n;
    vector<int> vec1(n+1);
    vector<int> vec2(m+1);
    for(int i=0;i&lt;=n;i++)
        vec1[i] = i;
    int cost = 0;</p>

<pre><code>for(int i=1;i&lt;=n;i++)
{
    vec2[0] = i;
    for(int j=1;j&lt;=m;j++)
    {
        if( str1[i-1] == str2[j-1] )
            cost = 0;
        else
            cost = 1;
        vec2[j] = vec2[j-1]+1 &lt; vec1[j]+1 ? vec2[j-1]+1 : vec1[j]+1;
        vec2[j] = vec2[j] &lt; vec1[j-1]+cost ? vec2[j] : vec1[j-1]+cost;
    }
    vec1 = vec2;
}
return vec2.back();
</code></pre>

<p>}</p>

<p>```</p>
]]></content>
  </entry>
  
</feed>
